# FPGA7
For the debouncer, I used logic similar to the clock divider from last week. When the raw input was pressed, I started a counter to 7. Once the counter had completed, if the raw input was still asserted, I would then assert the clean output. The testbench simulated this by asserting the raw input and then waiting the 8 clock cycles until the clean output was asserted.

For the moore FSM, I initialized an array to keep track of the current state. Since this is a moore FSM, the output z is only asserted if the current state is state 4. For each state, I placed a conditional telling the program what state to move to on the next clock cycle according to the diagram I created earlier. For my testbench, first I inputted the pattern that produces a high output, then some random values to show that the code executes according to the logic given.

For the mealy FSM, I again initialized an array to keep track of the current state. Since this is a mealy FSM, the output z is only asserted if the current state is state 3 and the input x is 1. Note that this cuts the number of states by 1. For each state, I again placed a conditional telling the program what state to move to on the next clock cycle according to the diagram I created earlier. For my testbench, first I inputted the pattern that produces a high output, then some random values to show that the code executes according to the logic given.
